1 page summary

[객체]
-모든 것, 물건, thing이라고 생각하면 쉽다
ex) 강아지 객체, 고양이 객체, 뱀 객체, 호랑이 객체....

-특성(변수, 필드), 행동(메소드, 기능)이 있다
ex) 강아지의 특성 - 이름, 나이
      강아지의 행동 - 짖기, 먹기

-데이터 (=변수=속성=필드) + 기능(=메소드=함수)을 하나로 묶어놓은 개념을 구체화 한 단위
-데이터와 기능을 합쳐 멤버라고 한다
-변수 + 메소드 구조로 C 구조체에 함수가 추가된 구조
-인스턴스 (instance)라고도 부른다

[클래스]
-객체를 만드는 레시피, 설계도
ex) 강아지 객체, 고양이 객체, 뱀 객체, 호랑이 객체를 만드는 동물 클래스

-여러개의 객체들이 있을 때 공통부분이 많다면 각 객체에 해당하는 클래스들을 각각 만들지 않고 하나의 클래스안에서 각각의 객체들을 구현할 수 있다
-소스 파일 하나당 하나의 클래스를 선언하는 것이 관례
-소스 파일 하나에 여러개의 클래스를 사용할 경우 소스파일과 동일한 이름의 클래스만 public을 쓸 수 있다
-메인 클래스를 분리하지 않고 한 클래스 내에서 사용할 경우 public static을 붙여 사용하면 된다

-접근 제한자 public, private등을 통해 다른 클래스에서 접근하는 것을 허용하거나 막을 수 있다

[접근 제한자]
-public, private 등이 있다
-같은 packages 내에서 public은 생략가능하다

[생성자]
-클래스의 이름과 동일한 메소드
-객체가 생성될 때 자동으로 한번 호출되며 정의하지 않으면 알아서 기본생성자를 만들어준다
-단 기본생성자가 아닌 다른 생성자가 이미 있을 경우 호출될 때 컴파일러가 기본생성자를 만들어주지 않으니 기본생성자는 항상 써두자
-리턴값이 없다
-객체를 생성할 때 초기화하기 위한 목적으로 사용
-생성자는 필요에 따라 여러개 작성가능하며 이름이 같아도 메소드 오버로딩에 의해 인자의 데이터타입과 수가 다르면 다르게 작동한다
-우클릭 -> source -> generate constructor using field -> 변수 체크 해제 -> generate -> super(); 메소드 삭제 -> 기본생성자 메소드 생성
-우클릭 -> source -> generate getter and setter -> 적용하고자 하는 변수 체크 -> 변수를 채우려고 하는 setter 메소드와 변수를 가져오려고 하는  getter 메소드 생성
-set은 변수에 값을 지정하려고 할 때 쓰고 get은 변수 값을 가져오려할 때 쓴다



ex)
Circle c; //Circle 클래스의 객체 c 선언 (stack 영역에 c이름을 가진 변수가 생성)
c = new Circle() //(변수 c가 힙영역의 Circle 타입의 객체를 가리켜서 객체 메모리가 할당되고 객체가 생성됨)
c.radius = 10 //.을 이용해 Circle 멤버에 접근할 수 있고 멤버의 값을 변경할 수 있다 (public인 경우만)
c.name = "자바피자"


[객체지향 프로그래밍]
-객체를 기반으로 프로그램을 작성하는 것
-가독성 (Readability), 재사용성(Reusability), 신뢰성(Reliability)이 중요
-상속성, 다형성, 캡슐형있다

[클래스 다이어그램]
-메소드이름은 띄어쓰기 하지 않는다
-메소드(기능)은 쉽게 떠오르나 변수(필드)는 쉽게 떠오르지 않으니 떠오르는 즉시 추가한다
-우클릭 -> java -> export 시 일반화 관계에서 하위에 있는 클래스들은 public class 하위클래스명 extend 상위 클래스명으로 export된다
-변수나 메소드 클릭 -> 우클릭 -> open property view -> visibility에서 public, private를 바꿀 수 있다

[관계]




[generalization]
-머리가 빈 삼각형 실선
-A는 B이다 관계
-A 클래스는 B 클래스의 내용을 재사용한다
-A 클래스는 B 클래스를 상위참조 한다
-A 클래스는 B 클래스를 상속받았다

[extend]
-머리가 빈 삼각형 점선
-A클래스는 B 클래스의 내용을 재사용하나 IC 기능을 추가적으로 가지고 있다

[객체지향의 특성]
[캡슐화] (=은닉성)
-노출할 필요가 없는 변수, 메소드는 접근 제한자 private를 이용해 전부 숨기기
-private 속성의 변수, 메소드를 이용할 때는  getter / setter를 이용한다

[상속성]
-일반화 관계의 상위 클래스와 하위 클래스가 있을 때 하위 클래스는 상위 클래스를 상속 받았다고 표현한다
-하위 클래스는 상위 클래스를 재사용하고 상위 클래스에는 없는 특성들이 추가될 수 있다
-상속은 하나만 받을 수 있다

[다형성]
-메소드의 이름이 같더라도 클래스나 객체에 따라 다르게 동작하도록 구현할 수 있다
-메소드 오버로딩 - 인자의 데이터 타입, 수에 따라 같은 이름의 메소드라도 다르게 구분할 수 있다
-this를 이용해 변수명/메소드명이 똑같은 경우에도 사용할 수 있다
ex)

-인자로 받는 radius 변수와 클래스 내의 radius 변수를 서로 구분해서 사용할 수 있다

[가비지컬렉터]
-더 이상 사용되지 않는 개체는 알아서 가비지컬렉터에 의해 정리된다
-따라서 소멸자를 따로 부르지 않아도 된다
-과도한 메모리 사용 방지 (free와 동일한 기능)

[객체 배열]
//선언
Circle [] c;
c = new Circle[5]

//대입
for (int i = 0; i < c.length; i++)
      c[i] = new Circle[i]





