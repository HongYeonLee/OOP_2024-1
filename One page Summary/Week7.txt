[상속]
-일반화 관계에서 상위 클래스가 private를 제외한 접근지정자타입의 메소드나 변수를 하위 클래스에게 물려주는 것
-하위 클래스는 상위 클래스에서 받은 메소드, 변수를 그대로 쓸 수 있으니 편하고,
-상위 클래스와 겹치는 부분을 하위 클래스에서 다시 선언할 필요가 없으니 깔끔해진다
-즉 하위 클래스는 상위 클래스와 겹치는 부분을 제외하고 추가할 부분만 따로 선언하면 된다
-단, 상속은 단일 상속만 가능하다 (아마테라스의 클래스 다이어그램을 작성할 때는 다중 상속이 가능하게 그려지는데 실제로는 오류발생)
-부모 클래스의 자식의 자식의 자식의..식으로 여러번 상속은 가능하나 (다중 상속과 다른 개념임) 2 - 4번이 적절하고 여러번 상속 보다는 인터페이스(메소드만 있는 클래스)를 사용해서 기능을 추가한다
-모든 클래스의 최상위 클래스는 java.lang.Object 클래스

사용방법
public class 하위클래스명 extends 상위클래스명
단일 상속만 가능하니 상위클래스명은 하나만 적는다


[접근지정자]
-private, public, protected, 디폴트
-private는 선언한 클래스 내에서만 자유롭게 사용
-상위 클래스의 디폴트 멤버는 '같은' 패키지 내의 모든 클래스에서 사용 가능
-그래서 상위 클래스를 물려받은 하위 클래스가 '다른' 패키지에 있으면 디폴트 멤버에 접근 불가능
-상위 클래스의 protected 멤버는 '같은' 패키지 내의 모든 클래스에서 사용 가능
-근데 그 상위 클래스를 물려받은 하위 클래스가 '다른' 패키지에 있어도 protected 멤버에 접근 가능
-private으로 선언된 변수에 접근하여 값을 리턴하거나 수정하려면 gettter와 setter 메소드를 이용한다


[생성자]
-객체가 생성될 때 초기화를 위해 실행되는 메소드
-기본 생성자와 생성자가 있다
-리턴 타입이 없다
-클래스의 이름과 동일해야 한다
-오버로딩이 가능

사용방법
-기본생성자
public 클래스명() //아무 인자가 없는 생성자가 기본 생성자
개발자가 만들지 않아도 new 클래스명(); 하게 되면 자동으로 생성되지만, 미리 만들어두는게 좋다
왜냐하면 개발자가 인자있는 다른 생성자를 하나라도 만들어두면 자바가 자동으로 기본생성자를 만들지 않기 때문이다

-생성자
public 클래스명(인자) //인자의 타입, 개수를 바꿔 똑같은 이름의 생성자 여러개 만들 수 있다 (메소드 오버로딩)

클래스명 변수명 = new 클래스명() //기본 생성자 호출, 이때 만약 기본생성자를 만들지 않아도 자바를 알아서 만든다
클래스명 변수명 = new 클래스명(인자) //인자가 있는 생성자 호출


[메소드 오버로딩, 오버라이딩]
-오버로딩은 생성자나 메소드를 인자의 타입이나 수를 바꿔서 (리턴타입을 바꾸는 건 아무 소용이 없다)
-같은 이름이더라도 사용할 수 있는 것을 말한다

-오버라이딩은 상위 클래스에서 물려받은 메소드의 내용물을 하위 클래스에 맞게 수정(=덮어쓰기=오버라이딩)해서 재활용하는 걸 말한다
-오버라이딩하지 않고 그냥 상위 클래스의 메소드를 쓰고 싶으면 this.상위클래스에서물려받은메소드명 or super.동일
-하지만 오버라이딩한 상태에서 this.물려받은메소드명을 하게 되면 오버라이딩으로 인해 동일한 이름의 자기 자신의 메소드를 계속 호출하게 되니 주의


[생성자의 호출순서]
-A←B←C 순으로 상위참조 되있다고 하자
-만약 메인에서 C c = new C(); 를 하게 되면
C 클래스의 기본생성자 호출 -> super()호출 -> B 클래스의 기본생성자 호출 -> super()호출 -> A 클래스의 기본생성자 호출 및 실행
->B 클래스의 기본생성자 실행 -> C 클래스의 기본생성자 실행


-super()는 개발자가 쓰지 않아도 자동으로 추가된다 (직접 작성할거라면 서브 클래스의 생성자에서 가장 첫 라인에 작성)
-super()는 상위 클래스의 기본생성자를 호출하는 것
-따라서 만약 상위 클래스에 기본생성자가 없으면 에러가 발생한다

-super(인자)를 하게되면 상위 클래스의 생성자를 호출하는 것

따라서, 하위 클래스 객체가 생성될 때, 하위 클래스의 생성자와 상위 클래스의 생성자가 모두 실행된다.
실행 순서는 상위 클래스 -> 하위 클래스 순
호출 순서는 하위 클래스 -> 상위 클래스 순