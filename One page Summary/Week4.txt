1 page summary

[반복문]

-for문
for (변수초기화; 조건식; 반복 후 작업)
{
//반복할 일
}

반복해서 합을 구할 때는 반드시 변수를 0으로 초기화 해줘야 한다 ex) sum += 변수를 사용하기 위해선 sum = 0 초기화 필요
반복해서 곱을 구할 때는 반드시 변수를 1로 초기화 해줘야 한다 ex) product  *= 변수를 사용하기 위해선 product = 1 초기화 필요
반복 후 작업은 주로 증감식이 오게되는데 for문 안에 있어도 된다

-while문
while (조건식)
{
//반복할 일
}
-건식을 통과한 후 반복할 일을 한다

//무한 루프 형식으로 작성하면 안에 if문을 통해 break;를 넣어야 한다
while (true)
{
//반복할 일
if (조건식) break;
}

//반복할 일을 최소 1번은 한 뒤에 조건식을 검토한다
do
{
//반복할 일
}
while (조건식);

//반복문을 통해 단순 숫자 연산뿐만 아니라 문자를 순서대로 출력할 수도 있다
//예제 3-3
char c = 'a';
반복문
{
c++'; 또는 c = char (c+1)
}
문자형 변수에 수를 증가 시킴으로써 다음 알파벳으로 바꿀 수 있다

[분기문]
-continue문
반복문을 빠져나가지 않고 다시 증감식이나 (for문의 경우) 조건식으로 되돌아 간다

for (int i = 0; i < n ; i++)
{
//
continue;
//
}
-> continue를 만나면 i++로 되돌아 간다

while (sum < 10)
{
//
continue;
//
}
-> continue를 만나면 sum < 10을 다시 체크한다

continue는 반복문을 돌리게하는 증감식의 위치가 중요하다


-break문
반복문을 빠져나가게 해주는 용도
다중 반복문에서 사용시 가장 안쪽 반복문에서만 벗어나고 여전히 다중 반복문 안에 있다


[배열]

-배열의 선언
데이터타입[ ]배열명;  //c처럼 배열명 옆에 대괄호를 칠 수 있지만 자바에서는 데이터 타입 옆에 대괄호를 주로 쓴다!

-배열 초기화
ex) int[] intarray = { 1, 2, 3 ... 10};
      int inarray[10]; //컴파일 에러가 난다, 배열 크기 지정x
     
      //다음과 같이 선언 및 초기화해야 한다
      int[] intarray = new int [10] 

-배열 접근
인덱스로 접근한다
인덱스는 0부터 시작하며 음수는 사용이 불가능하다
배열의 마지막 원소의 인덱스는 (배열의 크기 - 1)이다
반드시 배열을 생성한 후에 접근해야 한다

하나의 배열에 여러개의 배열이 접근할 수 있다 이를 배열 공유라고 한다
ex) int array1[] = new int[5];
      int array2[] = array1 //array2가 array1을 참조, 둘을 공유 상태가 됨

배열.length를 통해 배열 원소의 개수(정수형)를 리턴받을 수 있다


[메소드]
main에 모든 연산을 적는 것보다는 메소드로 분리하여 모듈화하는 것이 가독성이 좋다
중첩메소드는 불가능하다

리턴타입 메소드이름()
{
//할 일
}}

//배열을 리턴하는 메소드
ex) int[] makeArray()
{
//할일
return 배열;
}

main 메소드는 반드시 pulbic static void main (String[] args)로 써야한다

[정렬]
버블 정렬
for (int i = 0; i < 배열.length; i++)
      for (int j = 0; j <배열.length - 1; j++)
       {
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
       }


[랜덤]
-Math.random() 메소드
한번에 0.0 에서 1.0까지의 실수를 리턴하므로 원하는 범위의 랜덤수를 얻기 위해선 적절한 연산을 해줘야 함
ex) 0 ~ 100을 얻고싶다면 Math.random() * 1000(그 이상의 숫자도 ok) %101 을 해줘야 한다
      0 ~ 10 -> Math.random() * 100 % 11
      20 ~ 40 -> (Math.random() *1000) % (40 - 20 + 1) + 20 
//20 ~ 40 원리
40 - 20 + 1 -> 21로 나눗셈 -> 0 ~ 20 까지의 범위로 변경됨 -> +20을 해주면 20 ~ 40 까지의 범위로 변경됨


-Random 클래스
Random 변수명 =  new Random()
변수명.nextInt()
-21억 ~ 21억 사이의 정수를 리턴하므로 이 역시 적절한 연산을 해줘야 한다
ex) Random r = new Random()
      int n = r.nextInt()%101 // 0 ~ 101 사이의 정수가 리턴되나 음수도 리턴되니 음수이면 부호를 바꾸는 작업이 필요

-중복되는 수 처리하기
얻을 정수의 범위만큼의 0으로 초기화된 배열을 선언한다
//만약 정수를 0 ~ 45 범위에서 랜덤으로 얻을 것이라면 크기 45의 정수 배열을 0으로 초기화하여 선언한다

랜덤을 통해 얻은 수와 동일한 인덱스의 배열 값을 1로 수정한다
//만약 0 ~ 45 사이에서 7을 뽑았으면 배열[7] = 1로  바꾼다

새로운 수를 뽑았을 때 배열을 한번 스캔하고 해당 수의 인덱스 값에 해당하는 배열의 값이 0으로 체크되있다면 그 수를 뽑고 1로 체크되있다면 다시 뽑아서 중복 수를 없앤다